<!DOCTYPE html>
<html lang="en-GB">

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<meta property="og:title" content="OCJP Chapter 1: Advanced Class Design" />
<meta property="og:description" content="Whoop dee doop
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://verric.github.io/2017/05/25/ocjp-chapter-1-advanced-class-design/" />



<meta property="article:published_time" content="2017-05-25T15:14:44&#43;10:00"/>

<meta property="article:modified_time" content="2017-05-25T15:14:44&#43;10:00"/>











<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="OCJP Chapter 1: Advanced Class Design"/>
<meta name="twitter:description" content="Whoop dee doop
"/>
<meta name="generator" content="Hugo 0.30.2" />


    
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "headline": "OCJP Chapter 1: Advanced Class Design",
  "url": "https://verric.github.io/2017/05/25/ocjp-chapter-1-advanced-class-design/",
  "wordCount": "1965",
  "datePublished": "2017-05-25T15:14:44&#43;10:00",
  "dateModified": "2017-05-25T15:14:44&#43;10:00",
  "author": {
    "@type": "Person",
    "name": ""
  },
  "keywords": "programming, study-notes"
}
</script>



    <link rel="canonical" href="https://verric.github.io/2017/05/25/ocjp-chapter-1-advanced-class-design/">

    <title>OCJP Chapter 1: Advanced Class Design | Verric&#39;s Blog</title>

    <!-- combined, minified CSS -->
    <link href="https://verric.github.iocss/style.css" rel="stylesheet" integrity="sha384-O8wjsnz02XiyrPxnhfF6AVOv6YLBaEGRCnVF&#43;DL3gCPBy9cieyHcpixIrVyD2JS5" crossorigin="anonymous">

    

    

    

    

  </head>

  <body>

    <div class="blog-masthead">
      <div class="container">
        <nav class="nav blog-nav">
          <a class="nav-link " href="https://verric.github.io"></a>
          
          
        </nav>
      </div>
    </div>

    <header class="blog-header">
      <div class="container">
        <h1 class="blog-title"><a href="https://verric.github.io" rel="home">Verric's Blog</a></h1>
        <p class="lead blog-description">Hugo tranquilpeak theme demo</p>
      </div>
    </header>

    <div class="container">
      <div class="row">
        <div class="col-sm-8 blog-main">

          


<article class="blog-post">
  <header>
    <h2 class="blog-post-title"><a href="https://verric.github.io/2017/05/25/ocjp-chapter-1-advanced-class-design/">OCJP Chapter 1: Advanced Class Design</a></h2>
    <p class="blog-post-meta"><time datetime="2017-05-25T15:14:44&#43;10:00">Thu May 25, 2017</time> by  in 
<i class="fa fa-folder" aria-hidden="true"></i>&nbsp;<a href="https://verric.github.io/categories/programming" rel="category tag">programming</a>, <a href="https://verric.github.io/categories/study-notes" rel="category tag">study-notes</a>


<i class="fa fa-tag" aria-hidden="true"></i>&nbsp;<a href="https://verric.github.io/tags/programming" rel="tag">programming</a>, <a href="https://verric.github.io/tags/study-notes" rel="tag">study-notes</a>

</p>
  </header>
  <p>Whoop dee doop
</p>

<h1 id="chapter-1-advanced-class-design">Chapter 1: Advanced Class Design</h1>

<!--toc-->

<h2 id="reviewing-oca-concepts">Reviewing OCA Concepts:</h2>

<h3 id="access-modifiers">Access Modifiers</h3>

<p><img src="http://i.imgur.com/H3dQK2O.png" alt="access modifiers table" /></p>

<h3 id="overloading-overriding">Overloading &amp; Overriding</h3>

<pre><code class="language-java">1: public class Bobcat {
2:   public void findDen() { }
3: }
1: public class BobcatKitten extends Bobcat {
2:   public void findDen() { } // OVERRIDE
3:   public void findDen(boolean b) { } //OVERLOAD
4:   public int findDen() throws Exception { return 0; } //DIFFERENT METHOD
5: }
</code></pre>

<ul>
<li><strong><em>Overriding</em></strong> occurs when an inherited method declares a method with the same <strong>method signature</strong> as a method in its inheritance tree</li>
<li><strong><em>Overloading</em></strong>  occurs when you have two or more methods have the same name, but different parameter list, that is, same name, different signatures.</li>
</ul>

<p><strong>Overriding</strong></p>

<ul>
<li>The access modifier must be the same or more accessible.</li>
<li>The return type must be the same or a more restrictive type, also known as covariant return types.</li>
<li>If any checked exceptions are thrown, only the same exceptions or subclasses of those exceptions are allowed to be thrown.</li>
</ul>

<p><strong>Overloading</strong> &ndash; overloading matches occur in the following order
 - Exact match by type
 - Matching a superclass type
 - Converting to a larger primitive type
 - Converting to an autoboxed type
 - Varargs</p>

<h3 id="abstract-classes">Abstract Classes</h3>

<ul>
<li>An abstract class can contain both abstract methods and concrete methods</li>
<li>Abstract classes can <strong>not</strong> be instantiated,</li>
<li>You can still use static members on abstract classes</li>
<li>A class <strong>must</strong> be declared abstract if it contains at least one abstract method.</li>
</ul>

<h3 id="static-and-final">Static and Final</h3>

<p><strong>Static</strong></p>

<ul>
<li>Can be used on members and classes  to tie the member to a class (rather than an instance)</li>
<li>You can not override a static method, you can only shadow it (hide it)</li>
</ul>

<p><strong>Final</strong></p>

<ul>
<li>Variables can not be reassigned once initialised</li>
<li>Methods can not be overrriden</li>
<li>Classes ca not be extended</li>
</ul>

<h3 id="imports">Imports</h3>

<ul>
<li>Direct import take precedence over wildcard imports</li>
<li><code>import</code> imports classes from a package</li>
<li><code>import static</code>imports <strong>static members</strong> from classes (eg, static fields and static methods)</li>
<li><code>import static</code> is correct <code>static import</code> will fail to compile</li>
</ul>

<h3 id="using-instacnceof">Using InstacnceOf</h3>

<ul>
<li>Same operator precedence as relational operators (higher than equality but lower than BEDMAS)</li>
<li>Used to determine if a class is an instance of class , a subclass (directly or indirectly), or a class that implements an interface (directly or indirectly).</li>
<li>If the two instances being compared <strong>share no heritage</strong> (other than inheriting from Object) you will get a compile time error.</li>
<li>The compiler only does the mentioned inheritance check only on classes  (not interfaces)</li>
<li><code>InstanceOf</code> only checks against interfaces at runtime</li>
<li>Common use case for instanceOf is doing a check before casting, generally in <code>public boolean equals(Object o)</code></li>
</ul>

<h3 id="understanding-virtual-method-invocation">Understanding Virtual Method Invocation</h3>

<ul>
<li>Virtual methods are just methods overridden in a subclass that get called at runtime.</li>
<li>This works when the reference is to the super class but the object is to a subclass</li>
<li>This only works on methods not instance fields</li>
</ul>

<pre><code class="language-java">abstract class Animal {
  public void careFor() {
  play();
  }
  public void play() {
  System.out.println(&quot;pet animal&quot;);
  }
}

class Lion extends Animal {
  public void play() {
  System.out.println(&quot;toss in meat&quot;);
  }
}

public class PlayWithAnimal {
  public static void main(String... args) {
  Animal animal = new Lion();
  animal.careFor();
  }
}
</code></pre>

<p>Here even though the animal refers to an <code>Animal</code> and calls <code>play</code> the output is <code>&quot;toss in meat&quot;</code> as Java will look for any overridden method in the subclass (the class on the right hand side the &ldquo;=&rdquo;)</p>

<h3 id="annotating-overridden-methods">Annotating Overridden Methods</h3>

<ul>
<li>The <strong>@Override</strong> annotation denotes to the compiler that the method should override a method from a parenting class or an interface.</li>
<li>If the annotated method does <strong>not override</strong> a method the compiler will throw an exception.</li>
<li>You can <strong>not override</strong> a field.</li>
</ul>

<h3 id="coding-equals-hashcode-and-tostring">Coding equals, hashCode, and toString</h3>

<h4 id="tostring">toString</h4>

<p>Signature  <strong><code>public String toString()</code></strong></p>

<ul>
<li>Generally used to information about the object in a human readable format.</li>
<li><code>System.out.print(ln)</code> will automatically call <code>toString()</code> on the passed in object.</li>
</ul>

<h4 id="equals">equals</h4>

<p>Signature <strong><code>public boolean equals(Object o)</code></strong></p>

<ul>
<li>Used to check whether two objects (<code>o</code> and <code>this</code>) are equal.</li>
<li>If no custom implementation is provided. The default behaviour is equivalent to reference comparison<br /></li>
</ul>

<p>Conventions for consistent results</p>

<ol>
<li><p>It is reflexive: For any non‐null reference value x, x.equals(x) should return true.</p></li>

<li><p>It is symmetric: For any non‐null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true.</p></li>

<li><p>It is transitive: For any non‐null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true.</p></li>

<li><p>It is consistent: For any non‐null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified.</p></li>

<li><p>For any non‐null reference value x, x.equals(null) should return false.</p></li>
</ol>

<h4 id="hashcode">hashcode</h4>

<p>Signature <strong><code>public int hashCode()</code></strong></p>

<ul>
<li>The hash code is generally used for objects being stored in a collection such as a HashMap, HashSet etc.</li>
<li>It is recommended practice to override <code>hashcode</code> when overriding <code>equals</code> so both are consistent with each other and are deterministic</li>
</ul>

<p>Conventions for overriding hashcode:</p>

<ol>
<li>The code returned should based off (or calculated) a constant value in the object (not a variable), that is consistent with its <code>equals</code> method</li>
<li>If calling <code>equals</code> on two methods returns true,  both objects should return the same hashcode</li>
<li>If calling <code>equals</code> on two methods return false, there is no obligation for them to return different results.</li>
</ol>

<h3 id="working-with-enums">Working with Enums</h3>

<p>Enums are used to represent a finite set of fixed values.
The primary benefit of enums over constant values (<code>static final</code>) is they guarantee compile time type</p>

<hr />

<p>safety.</p>

<pre><code class="language-java">public enum Season{
  WINTER, SPRING, SUMMER, FALL
}
</code></pre>

<ul>
<li>Under the hood enums are static final constants</li>
<li>You can use  <code>==</code> to check if two enums are equal by value</li>
<li>You can obtain an iterator from the enum by calling the  <code>values()</code> method</li>
</ul>

<p>As Enums are compile constants they can be used in switch statements.</p>

<ul>
<li>When using an enum in a switch statement you do not have to provide the enum class as part of the <code>case</code>.
<code>java
Season s...;
switch(s) {
case SUMMER: ...;
case Season.WINTER ...; // Fails to compile
}
</code></li>
</ul>

<h4 id="adding-constructors-fields-and-methods">Adding Constructors, Fields, and Methods</h4>

<p>It is possible for enums to have state as well as their values.</p>

<pre><code class="language-java">public enum Season {
  WINTER(&quot;Low&quot;), SPRING(&quot;Medium&quot;), SUMMER(&quot;High&quot;), FALL(&quot;Medium&quot;);
  private String expectedVisitors;

  private Season(String expectedVisitors) {
    this.expectedVisitors = expectedVisitors;
  }

  public void printExpectedVisitors() {
  System.out.println(expectedVisitors);
   }
 }
</code></pre>

<p>Here it is important to note:</p>

<ol>
<li>We put a semi colon at the end of the enum declaration as they now have values.</li>
<li>The constructor has to BE <code>private</code>, being public will cause a compiler error.</li>
</ol>

<p>The constructor is called exactly once, internally by the JVM, hence the constructor is allowed to be <code>private</code></p>

<p>Enums can also have methods, you can declare a method and then use braces to &lsquo;override&rsquo; the method body.</p>

<pre><code class="language-java">public enum Season {
  WINTER {
    public void printHours() { System.out.println(&quot;9am-3pm&quot;); }
   },

  SPRING {
    public void printHours() { System.out.println(&quot;9am-5pm&quot;); }
  },

  SUMMER {
    public void printHours() { System.out.println(&quot;9am-7pm&quot;); }
  },

  FALL {
    public void printHours() { System.out.println(&quot;9am-5pm&quot;); }
  }; // note semi-colon

public void printHours() { System.out.println(&quot;default hours&quot;); }

}
</code></pre>

<h2 id="creating-nested-classes">Creating Nested Classes</h2>

<p>There are four types if inner classes in Java</p>

<blockquote>
<ol>
<li>A member inner class is a class defined at the same level as instance variables. It is not static. Often, this is just referred to as an inner class without explicitly saying the type.</li>
<li>A local inner class is defined within a method.</li>
<li>An anonymous inner class is a special case of a local inner class that does not have a name.</li>
<li>A static nested class is a static class that is defined at the same level as static variables.</li>
</ol>
</blockquote>

<h3 id="member-inner-classes">Member Inner Classes</h3>

<blockquote>
<p>A member inner class is defined at the member level of a class (the same level as the methods,
instance variables, and constructors). Member inner classes have the following properties:</p>
</blockquote>

<ol>
<li>Can be declared public, private, or protected or use default access</li>
<li>Can extend any class and implement interfaces</li>
<li>Can be abstract or final</li>
<li>CANNOT declare static fields or methods</li>
<li>Can access members of the outer class including private members</li>
</ol>

<pre><code class="language-java">public class Outer {

  private String greeting = &quot;Hi&quot;;

  protected class Inner {
    public int repeat = 3;

    public void go() {
      for (int i = 0; i &lt; repeat; i++)
        System.out.println(greeting);
      }
    }

  public void callInner() {
    Inner inner = new Inner();
    inner.go();
  }

  public static void main(String[] args) {
    Outer outer = new Outer();
    outer.callInner();
  }
}
</code></pre>

<p>This works fine as inner member classes can still access the outer classes private (non-static) members.</p>

<p>You could also create the inner instance directly by using dot notation followed by the <code>new</code> keyword</p>

<pre><code class="language-java">public static void main(String[] args) {
  Outer outer = new Outer();
  Inner inner = outer.new Inner(); // create the inner class
  inner.go();
}
</code></pre>

<h3 id="local-inner-classes">Local Inner Classes</h3>

<blockquote>
<p>A local inner class is a nested class defined within a method. Like local variables, a local inner class declaration does not exist until the method is invoked, and it goes out of scope when the method returns.</p>
</blockquote>

<ol>
<li>They do not have an access specifier.</li>
<li>They cannot be declared static and cannot declare static fields or methods.</li>
<li>They have access to all fields and methods of the enclosing class.</li>
<li>They do not have access to local variables of a method unless those variables are final or effectively final.</li>
</ol>

<pre><code class="language-Java">public class Outer {
  public void calculate() {
    final int width = 20; //local variable has to be final or 'effectively final' if they are to be accessed by the local inner class
    class Inner {
      public void multiply() {
        System.out.println(5 * width); //width variables used within `Inner` class
      }
    }
    Inner inner = new Inner();
    inner.multiply();  
  }
}
</code></pre>

<p>As an aside, the reason this concept is required is that Java will produce two classes here, the outer class will be compiled to <code>Outer.class</code> and the inner class will be compiled to <code>Outer$Inner.class</code></p>

<p>As they are two separate classes they do not share the same local variables, however if Java (the compiler at least) is able to guarantee that the value in a local variable is final (with or without the keyword) Java can &lsquo;copy&rsquo; of the variable and store it within the inner class.</p>

<p>Java considers a variable <code>effectively final</code> if it is initialised and is never changed afterwards. (As if the final keyword had been applied)</p>

<h3 id="anonymous-inner-class">Anonymous Inner Class</h3>

<blockquote>
<p>An anonymous inner class is a local inner class that does not have a name. It is declared and instantiated all in one statement using the new keyword.</p>
</blockquote>

<pre><code class="language-java">public class AnonInner {
  abstract class SaleTodayOnly {
  abstract int dollarsOff();
  }

  public int admission(int basePrice) {
  SaleTodayOnly sale = new SaleTodayOnly() { //here we are providing the implementing body directly.
    int dollarsOff() { return 3; }
  }; //SEMI COLON as we are defining a variable here, called 'sale'

  return basePrice - sale.dollarsOff();
  }
}
</code></pre>

<p>As anonymous classes are essentially &lsquo;defining the method body of another class&rsquo;, generally abstract such as in abstract classes or interfaces, anonymous classes can not extend or implement any additionally interfaces.</p>

<h3 id="static-nested-classes">Static Nested Classes</h3>

<blockquote>
<p>A static nested class is a static class defined at the member level. It can be instantiated without an object of the enclosing class, so it can’t access the instance variables without an explicit object of the enclosing class.</p>
</blockquote>

<p>A static class has the following properties</p>

<ol>
<li>The nesting creates a namespace because the enclosing class name must be used to refer to it.</li>
<li>It can be made private or use one of the other access modifiers to encapsulate it.</li>
<li>The enclosing class can refer to the fields and methods of the static nested class.</li>
</ol>

<pre><code class="language-java">public class Enclosing {
  static class Nested {
    private int price = 6;
  }

  public static void main(String[] args) {
    Nested nested = new Nested(); // no need for new Enclosing.Nested();
    System.out.println(nested.price); // Enclosing class can access private variables of the Nested class
  }
}
</code></pre>

<p><img src="http://i.imgur.com/VXLZz9Q.png" alt="Inner classes table" /></p>

  

  
  <hr>
  <footer>

  
    <section>
    <h4></h4>
    <nav class="nav sharing-icons">
      <a class="nav-item" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fverric.github.io%2f2017%2f05%2f25%2focjp-chapter-1-advanced-class-design%2f" title="Share on Facebook"><span class="fa fa-facebook fa-2x" aria-hidden="true"></span></a>
      <a class="nav-item" href="https://plus.google.com/share?url=https%3a%2f%2fverric.github.io%2f2017%2f05%2f25%2focjp-chapter-1-advanced-class-design%2f" title="Share on Google+"><span class="fa fa-google-plus fa-2x" aria-hidden="true"></span></a>
      <a class="nav-item" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fverric.github.io%2f2017%2f05%2f25%2focjp-chapter-1-advanced-class-design%2f" title="Share on LinkedIn"><span class="fa fa-linkedin fa-2x" aria-hidden="true"></span></a>
      <a class="nav-item" href="https://twitter.com/home?status=https%3a%2f%2fverric.github.io%2f2017%2f05%2f25%2focjp-chapter-1-advanced-class-design%2f" title="Tweet this"><span class="fa fa-twitter fa-2x"></span></a>
    </nav>
  </section>

  

  
  </footer>
  

</article> 



        </div> <!-- /.blog-main -->

        <aside class="col-sm-3 ml-auto blog-sidebar">
  

  

  
</aside>


      </div> <!-- /.row -->
    </div> <!-- /.container -->

    <footer class="blog-footer">
      <p>
      
      Blog template created by <a href="https://twitter.com/mdo">@mdo</a>, ported to Hugo by <a href='https://twitter.com/mralanorth'>@mralanorth</a>.
      
      </p>
      <p>
      <a href="#"></a>
      </p>
    </footer>

  </body>

</html>
